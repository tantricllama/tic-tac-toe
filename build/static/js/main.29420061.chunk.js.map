{"version":3,"sources":["types/index.ts","reducers/game.ts","actions/index.ts","store/index.ts","middleware/checkIfCellIsFilled.ts","middleware/checkIfOver.ts","middleware/checkIfWon.ts","middleware/nextTurn.ts","components/Cell.tsx","components/Board.tsx","components/Footer.tsx","components/App.tsx","index.tsx"],"names":["NEW_GAME","TAKE_TURN","GAME_WON","GAME_OVER","SWITCH_PLAYER","NEXT_TURN_REQUEST","NEXT_TURN_SUCCESS","NEXT_TURN_FAILURE","initialState","board","current","player","winner","winningCells","takeTurn","row","col","type","gameWon","getNextTurn","layout","_ref","Object","asyncToGenerator","regenerator_default","a","mark","_callee","dispatch","url","wrap","_context","prev","next","abrupt","fetch","then","response","json","data","success","hints","catch","error","failure","stop","_x","apply","this","arguments","middlewares","store","action","_store$getState","getState","n","r","c","cells","push","rowHasWon","length","colHasWon","diagonalHasWon","_store$getState2","thunk","createStore","state","undefined","objectSpread","slice","applyMiddleware","toConsumableArray","Cell","_classes","_this$props","props","value","classes","cell","defineProperty","forEach","win","react","className","classNames","onClick","React","connect","Board","map","rowIndex","colIndex","components_Cell","key","Footer","footerText","newGame","switchPlayer","text","App","components_Board","components_Footer","ReactDOM","es","App_App","document","getElementById"],"mappings":"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","file":"static/js/main.29420061.chunk.js","sourcesContent":["export const NEW_GAME = 'NEW_GAME';\r\nexport const TAKE_TURN = 'TAKE_TURN';\r\nexport const GAME_WON = 'GAME_WON';\r\nexport const GAME_OVER = 'GAME_OVER';\r\nexport const SWITCH_PLAYER = 'SWITCH_PLAYER';\r\n\r\nexport interface GameState {\r\n  board: string[][];\r\n  current: string;\r\n  player: string;\r\n  winner?: string | null;\r\n  winningCells: number[][];\r\n};\r\n\r\ninterface NewGame {\r\n  type: typeof NEW_GAME;\r\n}\r\n\r\ninterface TakeTurn {\r\n  type: typeof TAKE_TURN;\r\n  row: number;\r\n  col: number;\r\n}\r\n\r\ninterface GameWon {\r\n  type: typeof GAME_WON;\r\n  winner: string;\r\n  winningCells: number[][];\r\n}\r\n\r\ninterface GameOver {\r\n  type: typeof GAME_OVER;\r\n}\r\n\r\ninterface SwitchPlayer {\r\n  type: typeof SWITCH_PLAYER;\r\n}\r\n\r\nexport type GameActions = NewGame | TakeTurn | GameWon | GameOver | SwitchPlayer;\r\n\r\n//\r\n\r\nexport const NEXT_TURN_REQUEST = 'NEXT_TURN_REQUEST';\r\nexport const NEXT_TURN_SUCCESS = 'NEXT_TURN_SUCCESS';\r\nexport const NEXT_TURN_FAILURE = 'NEXT_TURN_FAILURE';\r\n\r\nexport interface AIState {\r\n  loading: boolean;\r\n  error: any;\r\n  r: number | null;\r\n  c: number | null;\r\n};\r\n\r\ninterface NextTurnRequest {\r\n  type: typeof NEXT_TURN_REQUEST;\r\n}\r\n\r\ninterface NextTurnSuccess {\r\n  type: typeof NEXT_TURN_SUCCESS;\r\n  data: any[];\r\n}\r\n\r\ninterface NextTurnFailure {\r\n  type: typeof NEXT_TURN_FAILURE;\r\n  error: any;\r\n}\r\n\r\nexport type AIActions = NextTurnRequest | NextTurnSuccess | NextTurnFailure;","import {\r\n  NEW_GAME,\r\n  TAKE_TURN,\r\n  GAME_WON,\r\n  GAME_OVER,\r\n  SWITCH_PLAYER,\r\n  GameState,\r\n  GameActions,\r\n} from '../types';\r\n\r\nconst initialState: GameState = {\r\n  board: [\r\n    ['', '', ''],\r\n    ['', '', ''],\r\n    ['', '', '']\r\n  ],\r\n  current: 'O',\r\n  player: 'O',\r\n  winner: null,\r\n  winningCells: []\r\n};\r\n\r\nexport default function(state = initialState, action: GameActions) {\r\n  switch (action.type) {\r\n    case NEW_GAME:\r\n      return {\r\n        ...state,\r\n        board: [\r\n          ['', '', ''],\r\n          ['', '', ''],\r\n          ['', '', '']\r\n        ],\r\n        current: 'O',\r\n        winner: null,\r\n        winningCells: []\r\n      };\r\n\r\n    case TAKE_TURN:\r\n      const board = state.board.slice(0);\r\n\r\n      board[action.row][action.col] = state.current;\r\n\r\n      return {\r\n        ...state,\r\n        board,\r\n        current: state.current === 'O' ? 'X' : 'O'\r\n      };\r\n      \r\n    case GAME_WON:\r\n      return {\r\n        ...state,\r\n        winner: action.winner,\r\n        winningCells: action.winningCells\r\n      };\r\n      \r\n    case GAME_OVER:\r\n      return {\r\n        ...state,\r\n        winner: ''\r\n      };\r\n    \r\n    case SWITCH_PLAYER:\r\n      return {\r\n        board: [\r\n          ['', '', ''],\r\n          ['', '', ''],\r\n          ['', '', '']\r\n        ],\r\n        current: 'O',\r\n        player: state.player === 'O' ? 'X' : 'O',\r\n        winner: null,\r\n        winningCells: []\r\n      };\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}","import { NEW_GAME, TAKE_TURN, GAME_WON, GAME_OVER, SWITCH_PLAYER, GameActions } from '../types';\r\nimport { NEXT_TURN_REQUEST, NEXT_TURN_SUCCESS, NEXT_TURN_FAILURE } from '../types';\r\n\r\nexport function newGame(): GameActions {\r\n  return {\r\n    type: NEW_GAME\r\n  };\r\n}\r\n\r\nexport function takeTurn(row: number, col: number): GameActions {\r\n  return {\r\n    type: TAKE_TURN,\r\n    row,\r\n    col\r\n  };\r\n}\r\n\r\nexport function gameWon(winner: string, winningCells: number[][]): GameActions {\r\n  return {\r\n    type: GAME_WON,\r\n    winner,\r\n    winningCells\r\n  };\r\n}\r\n\r\nexport function gameOver(): GameActions {\r\n  return {\r\n    type: GAME_OVER\r\n  };\r\n}\r\n\r\nexport function switchPlayer(): GameActions {\r\n  return {\r\n    type: SWITCH_PLAYER\r\n  };\r\n}\r\n\r\nexport function getNextTurn(player: string, layout?: string): any {\r\n  return async function(dispatch: any) {\r\n    dispatch(request());\r\n\r\n    var url = 'http://127.0.0.1:8000/move/' + player;\r\n    if (layout) {\r\n      url += '/' + layout + '/';\r\n    }\r\n\r\n    return fetch(url)\r\n      .then(response => response.json())\r\n      .then(data => {\r\n        dispatch(success(data));\r\n        dispatch(takeTurn(data.hints[0], data.hints[1]));\r\n\r\n        return data;\r\n      })\r\n      .catch(error => dispatch(failure(error)));\r\n  }\r\n\r\n  function request() { return { type: NEXT_TURN_REQUEST } }\r\n  function success(data: any[]) { return { type: NEXT_TURN_SUCCESS, data } }\r\n  function failure(error: any) { return { type: NEXT_TURN_FAILURE, error } }\r\n}","import { createStore, applyMiddleware, Middleware } from 'redux';\r\nimport logger from 'redux-logger';\r\nimport thunk from 'redux-thunk';\r\nimport rootReducer from '../reducers/game';\r\nimport checkIfCellIsFilled from '../middleware/checkIfCellIsFilled';\r\nimport checkIfWon from '../middleware/checkIfWon';\r\nimport checkIfOver from '../middleware/checkIfOver';\r\nimport nextTurn from '../middleware/nextTurn';\r\n\r\nconst middlewares = [\r\n  checkIfCellIsFilled,\r\n  checkIfOver,\r\n  checkIfWon,\r\n  nextTurn,\r\n  thunk\r\n];\r\n\r\nif (process.env.NODE_ENV === 'development') {\r\n  middlewares.push(logger);\r\n}\r\n\r\nconst store = createStore(\r\n  rootReducer,\r\n  applyMiddleware(...middlewares as Middleware[])\r\n);\r\n\r\nexport default store;","import { Store } from 'redux';\r\nimport { TAKE_TURN, GameActions } from '../types';\r\n\r\n// Checks to see if the cell can be filled\r\nexport default function checkIfCellIsFilled(store: Store) {\r\n  return function(next: any) {\r\n    return function(action: GameActions) {\r\n      if (action.type === TAKE_TURN) {\r\n        const { board, winner } = store.getState();\r\n\r\n        // If there is a winner then we cant fill the cell\r\n        if (winner !== null) return;\r\n\r\n        // If the cell is already filled we cant fill the cell\r\n        if (board[action.row][action.col] !== '') return;\r\n      }\r\n\r\n      return next(action);\r\n    }\r\n  }\r\n}","import { gameOver } from '../actions';\r\nimport { Store } from 'redux';\r\nimport { TAKE_TURN, GameActions } from '../types';\r\n\r\n// Checks to see if all cells are filled\r\nexport default function checkIfOver(store: Store) {\r\n  return function(next: any) {\r\n    return function(action: GameActions) {\r\n      // We still need to take the turn so the action will continue anyway\r\n      var n = next(action);\r\n\r\n      if (action.type === TAKE_TURN) {\r\n        const { board, winner } = store.getState();\r\n\r\n        if (winner === null) {\r\n          for (var r = 0; r < 3; r++) {\r\n            for (var c = 0; c < 3; c++) {\r\n              // Ignore the chosen cell because it wont be set\r\n              if (action.row === r && action.col === c) continue;\r\n\r\n              // If the cell is empty then the game is not over\r\n              if (board[r][c] === '') return null;\r\n            }\r\n          }\r\n\r\n          return store.dispatch(gameOver());\r\n        }\r\n      }\r\n\r\n      return n;\r\n    }\r\n  }\r\n}","import { Store } from 'redux';\r\nimport { gameWon } from '../actions';\r\nimport { TAKE_TURN, GameActions } from '../types';\r\n\r\n// Checks to see if the current player has won\r\nexport default function checkIfWon(store: Store) {\r\n  return function(next: any) {\r\n    return function(action: GameActions) {\r\n      if (action.type === TAKE_TURN) {\r\n        const { board, current } = store.getState();\r\n\r\n        // Check the row\r\n        var cells = rowHasWon(action.row, action.col, board, current);\r\n        if (cells.length) {\r\n          store.dispatch(gameWon(current, cells));\r\n        }\r\n\r\n        // Check the column\r\n        cells = colHasWon(action.row, action.col, board, current);\r\n        if (cells.length) {\r\n          store.dispatch(gameWon(current, cells));\r\n        }\r\n\r\n        // Check diagonally\r\n        cells = diagonalHasWon(action.row, action.col, board, current);\r\n        if (cells.length) {\r\n          store.dispatch(gameWon(current, cells));\r\n        }\r\n      }\r\n\r\n      return next(action);\r\n    }\r\n  }\r\n}\r\n\r\nfunction rowHasWon(row: number, col: number, board: string[][], current: string) {\r\n  var cells = [[row, col]];\r\n\r\n  for (var c = 0; c < 3; c++) {\r\n    if (c === col) continue; // Ignore the selected row as its not set yet\r\n\r\n    // Check if the cell is empty or set to the other player\r\n    if (board[row][c] === '' || board[row][c] !== current) {\r\n      return [];\r\n    }\r\n\r\n    cells.push([row, c]);\r\n  }\r\n\r\n  return cells;\r\n}\r\n\r\nfunction colHasWon(row: number, col: number, board: string[][], current: string) {\r\n  var cells = [[row, col]];\r\n\r\n  for (var r = 0; r < 3; r++) {\r\n    if (r === row) continue; // Ignore the selected column as its not set yet\r\n\r\n    // Check if the cell is empty or set to the other player\r\n    if (board[r][col] === '' || board[r][col] !== current) {\r\n      return [];\r\n    }\r\n\r\n    cells.push([r, col]);\r\n  }\r\n\r\n  return cells;\r\n}\r\n\r\nfunction diagonalHasWon(row: number, col: number, board: string[][], current: string) {\r\n  // Top left to bottom right\r\n  if (\r\n    ((row === 0 && col === 0) || board[0][0] === current) &&\r\n    ((row === 1 && col === 1) || board[1][1] === current) &&\r\n    ((row === 2 && col === 2) || board[2][2] === current)\r\n  ) {\r\n    return [[0, 0], [1, 1], [2, 2]];\r\n  }\r\n\r\n  // Bottom left to top right\r\n  if (\r\n    ((row === 2 && col === 0) || board[2][0] === current) &&\r\n    ((row === 1 && col === 1) || board[1][1] === current) &&\r\n    ((row === 0 && col === 2) || board[0][2] === current)\r\n  ) {\r\n    return [[2, 0], [1, 1], [0, 2]];\r\n  }\r\n\r\n  // No match\r\n  return [];\r\n}","import { getNextTurn } from '../actions';\r\nimport { Store } from 'redux';\r\nimport { TAKE_TURN, GameActions, SWITCH_PLAYER, NEW_GAME } from '../types';\r\n\r\n// Checks to see if all cells are filled\r\nexport default function aiTurn(store: Store) {\r\n  return function(next: any) {\r\n    return function(action: GameActions) {\r\n      // We still need to take the turn so the action will continue anyway\r\n      var n = next(action);\r\n\r\n      if (action.type === NEW_GAME || action.type === SWITCH_PLAYER) {\r\n        const { current, player } = store.getState();\r\n\r\n        if (current !== player) {\r\n          return store.dispatch(getNextTurn(current));\r\n        }\r\n      } else if (action.type === TAKE_TURN) {\r\n        const { board, current, player, winner } = store.getState();\r\n\r\n        if (current !== player && winner === null) {\r\n          var layout = '';\r\n          for (var r = 0; r < 3; r++) {\r\n            for (var c = 0; c < 3; c++) {\r\n              if (board[r][c] === '') {\r\n                layout += '.';\r\n              } else {\r\n                layout += board[r][c];\r\n              }\r\n            }\r\n          }\r\n\r\n          return store.dispatch(getNextTurn(current, layout));\r\n        }\r\n      }\r\n\r\n      return n;\r\n    }\r\n  }\r\n}","import * as React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport classNames from 'classnames';\r\nimport { takeTurn } from '../actions';\r\n\r\ntype Props = {\r\n  value: string;\r\n  row: number;\r\n  col: number;\r\n  takeTurn: any;\r\n  winner: string;\r\n  winningCells: number[][];\r\n}\r\n\r\nclass Cell extends React.Component<Props> {\r\n  render() {\r\n    const { value, takeTurn, row, col, winner, winningCells } = this.props;\r\n    var classes = {\r\n      cell: true,\r\n      [value]: true,\r\n      loss: winner === ''\r\n    };\r\n\r\n    winningCells.forEach(function(cells) {\r\n      if (cells[0] === row && cells[1] === col) {\r\n        classes.win = true;\r\n      }\r\n    });\r\n\r\n    return (\r\n      <div className={classNames(classes)} onClick={() => takeTurn(row, col)}>{value}</div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction mapStateToProps(state: Props) {\r\n  return {\r\n    winner: state.winner,\r\n    winningCells: state.winningCells\r\n  };\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: any) {\r\n  return {\r\n    takeTurn: (row: number, col: number) => dispatch(takeTurn(row, col))\r\n  };\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Cell);","import * as React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport Cell from './Cell';\r\n\r\ntype Props = {\r\n  board: string[][];\r\n}\r\n\r\nclass Board extends React.Component<Props> {\r\n  render() {\r\n    const { board } = this.props;\r\n\r\n    return (\r\n      <div className=\"board\">\r\n        {board.map((row, rowIndex) =>\r\n          row.map((value, colIndex) =>\r\n            <Cell key={rowIndex + '_' + colIndex} value={value} row={rowIndex} col={colIndex} />\r\n          ))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction mapStateToProps(state: Props) {\r\n  return {\r\n    board: state.board\r\n  };\r\n}\r\n\r\nexport default connect(mapStateToProps)(Board);","import * as React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { newGame, switchPlayer } from '../actions';\r\n\r\nexport interface Props {\r\n  current: string;\r\n  player: string;\r\n  winner?: string;\r\n  newGame: any;\r\n  switchPlayer: any;\r\n}\r\n\r\nclass Footer extends React.Component<Props> {\r\n  render() {\r\n    const { current, player, winner, newGame, switchPlayer } = this.props;\r\n\r\n    var footerText;\r\n    if (winner === null) {\r\n      footerText = <p>You are <strong className={player}>{player}</strong>, it is <strong className={current}>{current}</strong>'s turn</p>;\r\n    } else if (winner === '') {\r\n      footerText = <p>Game Over, nobody won!</p>;\r\n    } else {\r\n      var text = winner === player ? 'win' : 'lost';\r\n      footerText = <p><strong className={winner}>You {text}!</strong></p>;\r\n    }\r\n\r\n    return (\r\n      <div className=\"footer\">\r\n        <div className=\"left\">\r\n          {footerText}\r\n        </div>\r\n        <div className=\"right\">\r\n          <p><span onClick={switchPlayer}>Switch</span> / <span onClick={newGame}>Reset</span></p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction mapStateToProps(state: Props) {\r\n  return {\r\n    current: state.current,\r\n    player: state.player,\r\n    winner: state.winner\r\n  };\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: any) {\r\n  return {\r\n    newGame: () => dispatch(newGame()),\r\n    switchPlayer: () => dispatch(switchPlayer())\r\n  };\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Footer);","import * as React from 'react';\nimport Board from './Board';\nimport Footer from './Footer';\n\nexport default class App extends React.Component<any> {\n  render() {\n    return (\n      <div className=\"game\">\n        <h1>Tic Tac Toe</h1>\n        <Board />\n        <Footer />\n      </div>\n    );\n  }\n}","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport './index.css';\nimport store from './store';\nimport App from './components/App';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}